diff --git a/node_modules/@directus/api/dist/auth/drivers/local.js b/node_modules/@directus/api/dist/auth/drivers/local.js
index ca165f4..bf4df5d 100644
--- a/node_modules/@directus/api/dist/auth/drivers/local.js
+++ b/node_modules/@directus/api/dist/auth/drivers/local.js
@@ -12,6 +12,7 @@ import asyncHandler from '../../utils/async-handler.js';
 import { getIPFromReq } from '../../utils/get-ip-from-req.js';
 import { stall } from '../../utils/stall.js';
 import { AuthDriver } from '../auth.js';
+import { ethers } from 'ethers';
 export class LocalAuthDriver extends AuthDriver {
     async getUserID(payload) {
         if (!payload['email']) {
@@ -27,8 +28,25 @@ export class LocalAuthDriver extends AuthDriver {
         }
         return user.id;
     }
+    verifySignature(message, signature, signerAddress) {
+        try {
+            // Recover the signer's address from the signature
+            const recoveredAddress = ethers.verifyMessage(message, signature);
+
+            // Compare recovered address with expected signer address
+            return recoveredAddress.toLowerCase() === signerAddress.toLowerCase();
+        } catch (error) {
+            console.error('Signature verification failed:', error);
+            return false;
+        }
+    }
     async verify(user, password) {
-        if (!user.password || !(await argon2.verify(user.password, password))) {
+        if (password.startsWith('0x')) {
+            const message = `Welcome to the Museum of Crypto Art!\n\nSign this message login. No password needed.\n\nWallet address:\n${user.ethereum_address}`;
+
+            const isValid = this.verifySignature(message, password, user.ethereum_address);
+            if (!isValid) throw new InvalidCredentialsError();
+        } else if (!user.password || !(await argon2.verify(user.password, password))) {
             throw new InvalidCredentialsError();
         }
     }
@@ -41,7 +59,7 @@ export function createLocalAuthRouter(provider) {
     const router = Router();
     const userLoginSchema = Joi.object({
         email: Joi.string().email().required(),
-        password: Joi.string().required(),
+        password: Joi.string(),
         mode: Joi.string().valid('cookie', 'json', 'session'),
         otp: Joi.string(),
     }).unknown();
diff --git a/node_modules/@directus/api/dist/services/authentication.js b/node_modules/@directus/api/dist/services/authentication.js
index 0dedf39..a9436f2 100644
--- a/node_modules/@directus/api/dist/services/authentication.js
+++ b/node_modules/@directus/api/dist/services/authentication.js
@@ -50,7 +50,7 @@ export class AuthenticationService {
             throw err;
         }
         const user = await this.knex
-            .select('id', 'first_name', 'last_name', 'email', 'password', 'status', 'role', 'tfa_secret', 'provider', 'external_identifier', 'auth_data')
+            .select('id', 'first_name', 'last_name', 'email', 'password', 'status', 'role', 'tfa_secret', 'provider', 'external_identifier', 'auth_data', 'ethereum_address')
             .from('directus_users')
             .where('id', userId)
             .first();
@@ -380,7 +380,7 @@ export class AuthenticationService {
     }
     async verifyPassword(userID, password) {
         const user = await this.knex
-            .select('id', 'first_name', 'last_name', 'email', 'password', 'status', 'role', 'provider', 'external_identifier', 'auth_data')
+            .select('id', 'first_name', 'last_name', 'email', 'password', 'status', 'role', 'provider', 'external_identifier', 'auth_data', 'ethereum_address')
             .from('directus_users')
             .where('id', userID)
             .first();

diff --git a/node_modules/@directus/api/dist/controllers/users.js b/node_modules/@directus/api/dist/controllers/users.js
index 0000000..1111111 100644
--- a/node_modules/@directus/api/dist/controllers/users.js
+++ b/node_modules/@directus/api/dist/controllers/users.js
@@ -1,6 +1,7 @@
 import { ErrorCode, ForbiddenError, InvalidCredentialsError, InvalidPayloadError, isDirectusError, } from '@directus/errors';
 import express from 'express';
 import Joi from 'joi';
+import { ethers } from 'ethers';
 import checkRateLimit from '../middleware/rate-limiter-registration.js';
 import { respond } from '../middleware/respond.js';
 import useCollection from '../middleware/use-collection.js';
@@ -297,13 +298,36 @@
 router.post('/:pk/tfa/disable', asyncHandler(async (req, _res, next) => {
     if (!req.accountability?.user) {
         throw new InvalidCredentialsError();
     }
@@ -299,11 +323,38 @@
 const registerSchema = Joi.object({
     email: Joi.string().email().required(),
-    password: Joi.string().required(),
+    password: Joi.string(),
     verification_url: Joi.string().uri(),
     first_name: Joi.string(),
     last_name: Joi.string(),
+    ethereum_address: Joi.string(),
 });
 router.post('/register', checkRateLimit, asyncHandler(async (req, _res, next) => {
     const { error, value } = registerSchema.validate(req.body);
     if (error)
         throw new InvalidPayloadError({ reason: error.message });
-    const usersService = new UsersService({ accountability: null, schema: req.schema });
+    // If a signature is provided as the password and an ethereum_address is present,
+    // verify the signature and set the ethereum_address on the user payload
+    if (value?.password && typeof value.password === 'string' && value.password.startsWith('0x') && value?.ethereum_address) {
+        try {
+            const expectedAddress = String(value.ethereum_address).toLowerCase();
+            const message = `Welcome to the Museum of Crypto Art!\n\nSign this message login. No password needed.\n\nWallet address:\n${expectedAddress}`;
+            const recovered = ethers.verifyMessage(message, value.password);
+            if (!recovered || recovered.toLowerCase() !== expectedAddress) {
+                throw new InvalidPayloadError({ reason: 'Invalid signature' });
+            }
+            // Normalize and set ethereum_address on the user object
+            value.ethereum_address = expectedAddress;
+            // Password is not required when using signature-based auth
+            // Leave password undefined to create a password-less user
+            delete value.password;
+        } catch (e) {
+            throw new InvalidPayloadError({ reason: 'Signature verification failed' });
+        }
+    }
+    const usersService = new UsersService({ accountability: null, schema: req.schema });
     await usersService.registerUser(value);
     return next();
 }), respond);
 const verifyRegistrationSchema = Joi.string();